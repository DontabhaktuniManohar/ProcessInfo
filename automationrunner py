import os
import requests
from pathlib import Path
import pandas as pd
from xml.etree import ElementTree as ET

# Setup
env_name = "TDC"
url_list_file = f"{env_name}.txt"
request_dir = Path("./request")
result_file = Path("code_result.csv")
report_file = Path("report_file.html")
bad_response_dir = Path("responsefiles/bad_responses")
response_dir = Path("responsefiles")

# Ensure necessary directories exist
os.makedirs(bad_response_dir, exist_ok=True)
os.makedirs(response_dir, exist_ok=True)

# Read URLs from file
with open(url_list_file, "r") as f:
    url_list = [line.strip() for line in f if line.strip()]

# Process XML files for each URL
results = []

for api_url in url_list:
    base_host = api_url.split("/")[2].split(":")[0]
    port = api_url.split("/")[2].split(":")[1]

    for xml_file in request_dir.glob("ECPD*.xml"):
        with open(xml_file, "r") as f:
            xml_data = f.read()

        # Perform HTTP POST request
        try:
            response = requests.post(
                api_url,
                headers={"Content-Type": "application/xml"},
                data=xml_data,
                timeout=10
            )
            status_code = response.status_code
            response_text = response.text
        except Exception as e:
            results.append((xml_file.name, "REQUEST_FAILED"))
            continue

        # Save raw response
        response_filename = response_dir / f"response_{base_host}_{port}_{xml_file.name}"
        with open(response_filename, "w") as f:
            f.write(response_text)

        # Handle non-200 HTTP codes
        if status_code != 200:
            results.append((xml_file.name, status_code))
            bad_file = bad_response_dir / f"bad_{base_host}_{port}_{xml_file.name}"
            with open(bad_file, "w") as f:
                f.write(response_text)
            continue

        # Parse XML and extract <code>
        try:
            root = ET.fromstring(response_text)
            code = root.findtext("code")
            results.append((xml_file.name, code if code else "NO_CODE"))
        except ET.ParseError:
            results.append((xml_file.name, "INVALID_XML"))
            bad_file = bad_response_dir / f"bad_{base_host}_{port}_{xml_file.name}"
            with open(bad_file, "w") as f:
                f.write(response_text)

# Save result to CSV and HTML
df = pd.DataFrame(results, columns=["FILE_NAME", "CODE"])
df.to_csv(result_file, index=False)
df.to_html(report_file, index=False)



import urllib.parse

if "application/x-www-form-urlencoded" in content_type.lower():
    # Parse and decode
    parsed = urllib.parse.parse_qs(response.text)
    if "response" in parsed:
        xml_str = parsed["response"][0]
    else:
        results.append((xml_file.name, "NO_RESPONSE_FIELD"))
        continue
else:
    xml_str = response.text

# Now parse XML
try:
    root = ET.fromstring(xml_str)
    code = root.find(".//ns:RespMsg/ns:Code", namespaces=ns)
    results.append((xml_file.name, code.text if code is not None else "NO_CODE"))
except ET.ParseError:
    results.append((xml_file.name, "INVALID_XML"))