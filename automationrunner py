import os
import requests
from pathlib import Path
import pandas as pd
from xml.etree import ElementTree as ET

# Setup
env_name = "TDC"
url_list_file = f"{env_name}.txt"
request_dir = Path("./request")
result_file = Path("code_result.csv")
report_file = Path("report_file.html")
bad_response_dir = Path("responsefiles/bad_responses")
response_dir = Path("responsefiles")

# Ensure necessary directories exist
os.makedirs(bad_response_dir, exist_ok=True)
os.makedirs(response_dir, exist_ok=True)

# Read URLs from file
with open(url_list_file, "r") as f:
    url_list = [line.strip() for line in f if line.strip()]

# Process XML files for each URL
results = []

for api_url in url_list:
    base_host = api_url.split("/")[2].split(":")[0]
    port = api_url.split("/")[2].split(":")[1]

    for xml_file in request_dir.glob("ECPD*.xml"):
        with open(xml_file, "r") as f:
            xml_data = f.read()

        # Perform HTTP POST request
        try:
            response = requests.post(
                api_url,
                headers={"Content-Type": "application/xml"},
                data=xml_data,
                timeout=10
            )
            status_code = response.status_code
            response_text = response.text
        except Exception as e:
            results.append((xml_file.name, "REQUEST_FAILED"))
            continue

        # Save raw response
        response_filename = response_dir / f"response_{base_host}_{port}_{xml_file.name}"
        with open(response_filename, "w") as f:
            f.write(response_text)

        # Handle non-200 HTTP codes
        if status_code != 200:
            results.append((xml_file.name, status_code))
            bad_file = bad_response_dir / f"bad_{base_host}_{port}_{xml_file.name}"
            with open(bad_file, "w") as f:
                f.write(response_text)
            continue

        # Parse XML and extract <code>
        try:
            root = ET.fromstring(response_text)
            code = root.findtext("code")
            results.append((xml_file.name, code if code else "NO_CODE"))
        except ET.ParseError:
            results.append((xml_file.name, "INVALID_XML"))
            bad_file = bad_response_dir / f"bad_{base_host}_{port}_{xml_file.name}"
            with open(bad_file, "w") as f:
                f.write(response_text)

# Save result to CSV and HTML
df = pd.DataFrame(results, columns=["FILE_NAME", "CODE"])
df.to_csv(result_file, index=False)
df.to_html(report_file, index=False)



import urllib.parse

if "application/x-www-form-urlencoded" in content_type.lower():
    # Parse and decode
    parsed = urllib.parse.parse_qs(response.text)
    if "response" in parsed:
        xml_str = parsed["response"][0]
    else:
        results.append((xml_file.name, "NO_RESPONSE_FIELD"))
        continue
else:
    xml_str = response.text

# Now parse XML
try:
    root = ET.fromstring(xml_str)
    code = root.find(".//ns:RespMsg/ns:Code", namespaces=ns)
    results.append((xml_file.name, code.text if code is not None else "NO_CODE"))
except ET.ParseError:
    results.append((xml_file.name, "INVALID_XML"))



import requests
import xml.etree.ElementTree as ET
import re

# Namespace used in the XML
ns = {'ns': 'http://www.vzw.com/namespaces/scmplus'}

def extract_valid_xml(xml_text):
    """
    Extracts the XML section from inside any wrapping junk like HTML.
    Looks for known root tag: <RespViewPurchases>...</RespViewPurchases>
    """
    match = re.search(r"(<RespViewPurchases.*?</RespViewPurchases>)", xml_text, re.DOTALL)
    return match.group(1) if match else None

def parse_respmsg_code(xml_string):
    try:
        root = ET.fromstring(xml_string)
        code = root.find(".//ns:RespMsg/ns:Code", namespaces=ns)
        return code.text if code is not None else "NO_CODE"
    except ET.ParseError as e:
        return f"INVALID_XML: {e}"

# Example URL and XML payload
url = "http://your-api-endpoint-here"
xml_payload = """<your-request-body-here>...</your-request-body-here>"""

try:
    response = requests.post(url, headers={"Content-Type": "application/xml"}, data=xml_payload, timeout=10)
    response_text = response.text.strip()

    # Try to extract only the valid XML part
    xml_clean = extract_valid_xml(response_text)

    if xml_clean:
        code = parse_respmsg_code(xml_clean)
        print("RespMsg Code:", code)
    else:
        print("Could not extract valid XML from response.")

except Exception as e:
    print("Request failed:", str(e))