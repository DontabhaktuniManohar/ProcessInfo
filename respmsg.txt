awk '
  /<RespMsg>/ { in_resp=1 }
  in_resp && /<Code>/ {
    match($0, /<Code>([^<]*)<\/[Cc]ode>/, m)
    if (m[1] != "") print m[1]
    in_resp=0
  }
' largefile.xml
#sed -n '/<RespMsg>/,/<\/RespMsg>/p' largefile.xml | sed -n 's:.*<[Cc]ode>\(.*\)</[Cc]ode>.*:\1:p'


#!/bin/bash

# === CONFIGURATION ===
URL="https://example.com/api"
REQUEST_DIR="./requests"
RESULT_FILE="code_result.log"
BAD_DIR="bad_responses"

mkdir -p "$BAD_DIR"
> "$RESULT_FILE"  # Clear previous result log

# === PROCESS EACH XML FILE ===
for XML_FILE in "$REQUEST_DIR"/*.xml; do
  FILE_NAME=$(basename "$XML_FILE")
  RESPONSE_FILE="response_$FILE_NAME"

  # POST the XML and capture status and output
  HTTP_RESPONSE=$(curl -s -w "%{http_code}" -o "$RESPONSE_FILE" \
    -X POST -H "Content-Type: application/xml" \
    --data @"$XML_FILE" "$URL")

  HTTP_CODE="${HTTP_RESPONSE: -3}"
  RESPONSE_BODY=$(<"$RESPONSE_FILE")

  # Check for HTTP success
  if [[ "$HTTP_CODE" != "200" ]]; then
    echo "$FILE_NAME  HTTP_$HTTP_CODE" >> "$RESULT_FILE"
    cp "$RESPONSE_FILE" "$BAD_DIR/bad_$FILE_NAME"
    continue
  fi

  # Check response content sanity
  if [[ -z "$RESPONSE_BODY" ]] || ! echo "$RESPONSE_BODY" | grep -q "<?xml"; then
    echo "$FILE_NAME  INVALID_XML" >> "$RESULT_FILE"
    cp "$RESPONSE_FILE" "$BAD_DIR/bad_$FILE_NAME"
    continue
  fi

  # Extract <Code> from <RespMsg>
  CODE=$(echo "$RESPONSE_BODY" | sed -n '/<RespMsg>/,/<\/RespMsg>/{
    /<[Cc]ode>/ s:.*<[Cc]ode>\(.*\)</[Cc]ode>.*:\1:p
  }')

  # Write result to file
  if [[ -n "$CODE" ]]; then
    echo "$FILE_NAME  $CODE" >> "$RESULT_FILE"
  else
    echo "$FILE_NAME  MISSING_CODE" >> "$RESULT_FILE"
    cp "$RESPONSE_FILE" "$BAD_DIR/bad_$FILE_NAME"
  fi
done


############################
#!/bin/bash

# === CONFIG ===
API1_URL="https://api1.example.com/endpoint"
API2_URL="https://api2.example.com/endpoint"
REQUEST_DIR="./requests"
RESULT_FILE="code_result.log"
BAD_DIR="bad_responses"
mkdir -p "$BAD_DIR"
> "$RESULT_FILE"

# === Function to POST and extract Code ===
post_and_get_code() {
  local url=$1
  local xml_file=$2
  local tmp_response=$3

  # Send POST and capture status
  http_status=$(curl -s -w "%{http_code}" -o "$tmp_response" \
    -X POST -H "Content-Type: application/xml" \
    --data @"$xml_file" "$url")

  # Check HTTP code
  if [[ "$http_status" != "200" ]]; then
    echo "HTTP_$http_status"
    return
  fi

  response_body=$(<"$tmp_response")

  # Sanity check
  if [[ -z "$response_body" ]] || ! echo "$response_body" | grep -q "<?xml"; then
    echo "INVALID_XML"
    return
  fi

  # Extract <Code>
  code=$(echo "$response_body" | sed -n '/<RespMsg>/,/<\/RespMsg>/{
    /<[Cc]ode>/ s:.*<[Cc]ode>\(.*\)</[Cc]ode>.*:\1:p
  }')

  if [[ -n "$code" ]]; then
    echo "$code"
  else
    echo "MISSING_CODE"
  fi
}

# === MAIN LOOP ===
for xml in "$REQUEST_DIR"/*.xml; do
  filename=$(basename "$xml")

  # Temp response files
  resp1="resp1_$filename"
  resp2="resp2_$filename"

  echo "Processing: $filename"

  code1=$(post_and_get_code "$API1_URL" "$xml" "$resp1")
  code2=$(post_and_get_code "$API2_URL" "$xml" "$resp2")

  echo "$filename  API1:$code1  API2:$code2" >> "$RESULT_FILE"

  # Optional: save bad responses
  [[ "$code1" != "200" ]] && cp "$resp1" "$BAD_DIR/bad_api1_$filename"
  [[ "$code2" != "200" ]] && cp "$resp2" "$BAD_DIR/bad_api2_$filename"
done

